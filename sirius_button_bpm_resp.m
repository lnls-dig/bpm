function [resp, t] = sirius_button_bpm_resp(beam_current, f, beampos, att1_val)

sirius_parameters;
sirius_bpmparameters;
physical_constants;

fe = bpm.cable.fe;
cablelength = bpm.cable.length;
beta = storagering.beta;
R0 = bpm.pickup.button.R0;
bd = bpm.pickup.button.diameter;
frf = storagering.frf;

% Beam current to image current response
% Choose button with the highest signal
CovF = beamcoverage(bpm.pickup, beampos, 500);
beam2bpm_current = max(CovF)*bd/(beta*c)*(1j*2*pi*f);

% Button impedance response
% (from beam image current to voltage on button)
%Cb = calccapacitance(bpm.pickup.button);
Cb = bpm.pickup.button.Cb_meas;
Zbutton = R0./(1+1j*2*pi*f*R0*Cb);

% Coaxial cable response (LMR195)
Zcable = exp(-(1+sign(f).*1j).*sqrt(abs(f)/fe)*cablelength/30.5);

% RFFE v2 low pass filter response
% Based on Mini-circuits LFCN-530 (https://www.minicircuits.com/pdfs/LFCN-530.pdf)
%flpf_spec = 1e6*[0 1 100 500 530 670 700 815 820 945 1315 2140 3000 3640 4910 6000 Inf];
%Glpf_spec = [0 -0.05 -0.22 -0.73 -0.81 -1.95 -2.89 -26.41 -28.41 -44.98 -39.77 -57.51 -47.94 -42.84 -18.81 -24.8 -24.8];
flpf_spec = 1e6*[0 1 100 500 530 670 700 815 820 945 1315 2140 3000 Inf];
Glpf_spec = [0 -0.05 -0.22 -0.73 -0.81 -1.95 -2.89 -26.41 -28.41 -44.98 -39.77 -57.51 -60 -60];
Glpf = interp1(flpf_spec, Glpf_spec, f);
Glpf = 10.^(Glpf/20);
LPF = mps(Glpf);

% RFFE v2 bandpass filter
% Based on TAI-SAW TA1113A (http://www.taisaw.com/upload/product/TA1113A%20_Rev.1.0_.pdf)
%fbpf_spec = [0 300e3 100e6 200e6 300e6 (frf-20e6) (frf-10e6) (frf+10e6) (frf+40e6) (frf+40e6+2500e6) Inf];
%Gbpf_spec = [-80 -80 -70 -60 -55 -52 -2 -2 -55 0 0];
fbpf_spec = [0 300e3 100e6 200e6 300e6 (frf-20e6) (frf-10e6) (frf+10e6) (frf+40e6) Inf];
Gbpf_spec = [-80 -80 -70 -60 -55 -52 -2 -2 -55 -55];
Gbpf = interp1(fbpf_spec, Gbpf_spec, f);
Gbpf = 10.^(Gbpf/20);
BPF = mps(Gbpf);

% RFFE v2 RF amplifier response (Mini-circuits TAMP-72LN)
amp_gain = 10;
amp_nonlinearity = [-0.048634 1 0];

% Attenuator response (Mini-circuits DAT-31R5-SP)
att1 = 10^(-1.5/20)*10^(-att1_val/20);

% RFFE-FMC ADC coaxial cable response
rffe_adc_cable_il = 10^(-0.5/20);

% FMC ADC analog front-end response
adc_afe_il = 10^(-2.5/20);

% ADC non-linearity response
adc_nonlinearity = [-0.001 1 0];

% Build frequency responses along signal path
names = {'Beam current', ...
         'BPM button current', ...
         'BPM button voltage', ... 
         'Coax. cable (BPM to RFFE)', ... 
         'RFFE LPF #1', ... 
         'RFFE BPF #1', ... 
         'RFFE Amp #1', ... 
         'RFFE Att #1', ... 
         'RFFE LPF #2', ... 
         'RFFE Amp #2', ... 
         'RFFE LPF #3', ... 
         'RFFE-FMC ADC coax. cable', ... 
         'ADC analog front-end', ...
         'ADC input', ...
         };
     
freqresps = {1, ...
             beam2bpm_current, ...
             Zbutton, ...
             Zcable, ...
             LPF, ...
             BPF, ...
             amp_gain, ...
             att1, ...
             LPF, ...
             amp_gain, ...
             LPF, ...
             rffe_adc_cable_il, ...
             adc_afe_il, ...
             1, ...
             };
         
nonlinearities = {[], ...
                  [], ...
                  [], ...
                  [], ...
                  [], ...
                  [], ...
                  amp_nonlinearity, ...
                  [], ...
                  [], ...
                  amp_nonlinearity, ...
                  [], ...
                  [], ...
                  [], ...
                  adc_nonlinearity, ...
                  };

[resp, t] = buildresp(beam_current, f, names, freqresps, nonlinearities);

function [resp, t] = buildresp(input_signal, f, names, freqresps, nonlinearities)

resp = struct('name', names{1}, 'freqresp', freqresps{1}, 'nonlinearity', nonlinearities{1}, 'signal_freq', input_signal, 'signal_time', fourierseries2time(abs(input_signal), angle(input_signal), f));

for i=2:length(names)
    resp(i).name = names{i};
    resp(i).freqresp = resp(i-1).freqresp.*freqresps{i};
    resp(i).nonlinearity = nonlinearities{i};
    resp(i).signal_freq = resp(i).freqresp.*resp(1).signal_freq;
    [resp(i).signal_time, t] = fourierseries2time(abs(resp(i).signal_freq), angle(resp(i).signal_freq), f);
    
    if ~isempty(nonlinearities{i})
        resp(i).signal_time = polyval(resp(i).nonlinearity, resp(i).signal_time);
    end
end